
bin/firmware.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <jump_reset>:
DUMMY_HANDLER void UART4_IRQHandler(void);
DUMMY_HANDLER void DMA1_Channel8_IRQHandler(void);
#endif  // SYS_USE_VECTORS > 0

// FLASH starts with a jump to the reset handler
void jump_reset(void) { asm volatile("j reset_handler"); }
   0:	14a0006f          	j	14a <reset_handler>

00000004 <init_data>:
   4:	00000013 00000013 00000013 00000013     ................
  14:	00000013 00000013 00000013 00000013     ................
  24:	00000013 00000013 00000013 00000013     ................
  34:	00100073                                s...

Disassembly of section .text:

00000134 <main>:
 134:	200007b7          	lui	a5,0x20000
 138:	0047a703          	lw	a4,4(a5) # 20000004 <var_a.1>
 13c:	200007b7          	lui	a5,0x20000
 140:	4501                	li	a0,0
 142:	00e7a023          	sw	a4,0(a5) # 20000000 <var_b.0>
 146:	8082                	ret

00000148 <ADC1_2_IRQHandler>:
void default_handler(void)    { while(1); }
 148:	a001                	j	148 <ADC1_2_IRQHandler>

0000014a <reset_handler>:
// Reset handler
void reset_handler(void) {
  uint32_t *src, *dst;
  
  // Set pointers, vectors, processor status, and interrupts
  asm volatile(
 14a:	13400793          	li	a5,308
 14e:	20000197          	auipc	gp,0x20000
 152:	6b218193          	addi	gp,gp,1714 # 20000800 <__global_pointer$>
 156:	20002117          	auipc	sp,0x20002
 15a:	6aa10113          	addi	sp,sp,1706 # 20002800 <_eusrstack>
 15e:	457d                	li	a0,31
 160:	bc051073          	csrw	0xbc0,a0
 164:	08800513          	li	a0,136
 168:	30051073          	csrw	mstatus,a0
 16c:	458d                	li	a1,3
 16e:	80459073          	csrw	0x804,a1
 172:	03800513          	li	a0,56
 176:	8d4d                	or	a0,a0,a1
 178:	30551073          	csrw	mtvec,a0
 17c:	34179073          	csrw	mepc,a5
  );

  // Copy data from FLASH to RAM
  src = &_data_lma;
  dst = &_data_vma;
  while(dst < &_edata) *dst++ = *src++;
 180:	200007b7          	lui	a5,0x20000
 184:	22000713          	li	a4,544
 188:	00078793          	mv	a5,a5
 18c:	80818693          	addi	a3,gp,-2040 # 20000008 <_ebss>
 190:	06d7ef63          	bltu	a5,a3,20e <system.c.5746ba08+0xa2>

  // Clear uninitialized variables
  #if SYS_CLEAR_BSS > 0
  dst = &_sbss;
  while(dst < &_ebss) *dst++ = 0;
 194:	80818793          	addi	a5,gp,-2040 # 20000008 <_ebss>
 198:	80818713          	addi	a4,gp,-2040 # 20000008 <_ebss>
 19c:	06e7ee63          	bltu	a5,a4,218 <system.c.5746ba08+0xac>
    RCC->INTR = 0x009F0000;                               // Clear ready flags
 1a0:	400217b7          	lui	a5,0x40021
 1a4:	009f0737          	lui	a4,0x9f0
 1a8:	c798                	sw	a4,8(a5)
  EXTEN->EXTEN_CTR |= EXTEN_PLL_HSI_PRE;                  // HSI not divided for PLL
 1aa:	40024737          	lui	a4,0x40024
 1ae:	80070713          	addi	a4,a4,-2048 # 40023800 <_eusrstack+0x20021000>
 1b2:	4314                	lw	a3,0(a4)
 1b4:	0106e693          	ori	a3,a3,16
 1b8:	c314                	sw	a3,0(a4)
  RCC->CFGR0 = RCC_HPRE_DIV1                              // HCLK = SYSCLK
 1ba:	003c0737          	lui	a4,0x3c0
 1be:	c3d8                	sw	a4,4(a5)
  RCC->CTLR |= RCC_PLLON;                                 // Enable PLL
 1c0:	4398                	lw	a4,0(a5)
 1c2:	010006b7          	lui	a3,0x1000
 1c6:	8f55                	or	a4,a4,a3
 1c8:	c398                	sw	a4,0(a5)
  while(!(RCC->CTLR & RCC_PLLRDY));                       // Wait till PLL is ready      
 1ca:	4398                	lw	a4,0(a5)
 1cc:	00671693          	slli	a3,a4,0x6
 1d0:	fe06dde3          	bgez	a3,1ca <system.c.5746ba08+0x5e>
  RCC->CFGR0 |= RCC_SW_PLL;                               // PLL as system clock source
 1d4:	43d8                	lw	a4,4(a5)
  while((RCC->CFGR0 & RCC_SWS) != (uint32_t)0x08);        // Wait for PLL
 1d6:	46a1                	li	a3,8
  RCC->CFGR0 |= RCC_SW_PLL;                               // PLL as system clock source
 1d8:	00276713          	ori	a4,a4,2
 1dc:	c3d8                	sw	a4,4(a5)
  while((RCC->CFGR0 & RCC_SWS) != (uint32_t)0x08);        // Wait for PLL
 1de:	400217b7          	lui	a5,0x40021
 1e2:	43d8                	lw	a4,4(a5)
 1e4:	8b31                	andi	a4,a4,12
 1e6:	fed71ee3          	bne	a4,a3,1e2 <system.c.5746ba08+0x76>
      FLASH->CTLR &= ~FLASH_CTLR_SCKMOD;                  // FLASH CLK = SYSCLK / 2
 1ea:	40022637          	lui	a2,0x40022
 1ee:	4a18                	lw	a4,16(a2)
 1f0:	fe0006b7          	lui	a3,0xfe000
 1f4:	16fd                	addi	a3,a3,-1 # fdffffff <_eusrstack+0xddffd7ff>
 1f6:	8f75                	and	a4,a4,a3
 1f8:	ca18                	sw	a4,16(a2)
  STK_init();
 1fa:	4695                	li	a3,5
 1fc:	e000f737          	lui	a4,0xe000f
 200:	c314                	sw	a3,0(a4)
  RCC->APB2PCENR |= RCC_IOPAEN | RCC_IOPBEN | RCC_IOPCEN | RCC_IOPDEN;
 202:	4f98                	lw	a4,24(a5)
 204:	03c76713          	ori	a4,a4,60
 208:	cf98                	sw	a4,24(a5)

  // Init system
  SYS_init();

  // Return
  asm volatile("mret");
 20a:	30200073          	mret
  while(dst < &_edata) *dst++ = *src++;
 20e:	4310                	lw	a2,0(a4)
 210:	0711                	addi	a4,a4,4 # e000f004 <_eusrstack+0xc000c804>
 212:	c390                	sw	a2,0(a5)
 214:	0791                	addi	a5,a5,4 # 40021004 <_eusrstack+0x2001e804>
 216:	bfad                	j	190 <system.c.5746ba08+0x24>
  while(dst < &_ebss) *dst++ = 0;
 218:	0007a023          	sw	zero,0(a5)
 21c:	0791                	addi	a5,a5,4
 21e:	bfbd                	j	19c <system.c.5746ba08+0x30>
